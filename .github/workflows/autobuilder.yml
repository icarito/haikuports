name: Build HaikuPorts packages

on:
  workflow_dispatch:
  push:
    branches: [ development ]
  pull_request:
    branches: [ main, master, development ]

jobs:
  prepare-build:
    runs-on: ubuntu-latest
    outputs:
      changed_recipes_space_separated: ${{ steps.detect-changes.outputs.changed_recipes_space_separated }}
      has_changed_recipes: ${{ steps.detect-changes.outputs.has_changed_recipes }}
    steps:
      - name: Checkout HaikuPorts repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python for HaikuPorter
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install HaikuPorter
        run: |
          git clone https://github.com/haikuports/haikuporter.git ~/haikuporter
          sudo ln -s "$HOME/haikuporter/haikuporter" /usr/local/bin/haikuporter
          echo "HaikuPorter installed. Version:"
          haikuporter --version
        shell: bash

      - name: Set up HaikuPorter configuration
        run: |
          echo "TREE_PATH=\"${{ github.workspace }}\"" > "${{ github.workspace }}/haikuports.conf"
          echo "PACKAGER=\"CI Builder <ci@example.com>\"" >> "${{ github.workspace }}/haikuports.conf"
          echo "TARGET_ARCHITECTURE=\"x86_64\"" >> "${{ github.workspace }}/haikuports.conf"
          echo "HaikuPorter configuration created at ${{ github.workspace }}/haikuports.conf:"
          cat "${{ github.workspace }}/haikuports.conf"
        shell: bash

      - name: Download Haiku Licenses
        run: |
          wget https://github.com/waddlesplash/haiku-licenses/archive/master.zip -O haiku-licenses.zip
          unzip -q haiku-licenses.zip
          echo "Haiku Licenses downloaded and unzipped. Found directories:"
          ls -d ${{ github.workspace }}/haiku-licenses-*/
        shell: bash

      - name: Detect modified recipes
        id: detect-changes
        run: |
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          GIT_PRIMARY_BRANCH_REF=""
          if git rev-parse --verify origin/main >/dev/null 2>&1; then
            GIT_PRIMARY_BRANCH_REF="origin/main"
          elif git rev-parse --verify origin/master >/dev/null 2>&1; then
            GIT_PRIMARY_BRANCH_REF="origin/master"
          fi

          if [ -z "$GIT_PRIMARY_BRANCH_REF" ]; then
            echo "::warning::No main or master branch found at origin to compare against. Assuming all recipes need checking."
            CHANGED_RECIPES=$(find . -name '*.recipe' -printf '%h\n' | sed 's|^\./||' | cut -d "/" -f 2 | sort -u | tr '\n' ' ')
            echo "build_all_flag=true" >> $GITHUB_OUTPUT
          else
            echo "Primary branch for comparison: $GIT_PRIMARY_BRANCH_REF"
            if [ "$GITHUB_EVENT_NAME" == "pull_request" ]; then
              TARGET_REF="origin/$GITHUB_BASE_REF"
              git fetch origin "$GITHUB_BASE_REF" --depth=1
              MERGE_BASE=$(git merge-base HEAD "$TARGET_REF")
              echo "Pull Request: Diffing from merge base $MERGE_BASE to HEAD ($GITHUB_SHA)"
              CHANGED_RECIPES=$(git diff --name-only "$MERGE_BASE" HEAD -- '*/*.recipe' | sed 's|/[^/]*\.recipe$||g' | cut -d "/" -f 2 | sort -u | tr '\n' ' ')
            else
              echo "Push/Manual Trigger: Diffing from $GIT_PRIMARY_BRANCH_REF to HEAD ($GITHUB_SHA)"
              CHANGED_RECIPES=$(git diff --name-only "$GIT_PRIMARY_BRANCH_REF...HEAD" -- '*/*.recipe' | sed 's|/[^/]*\.recipe$||g' | cut -d "/" -f 2 | sort -u | tr '\n' ' ')
            fi
            echo "build_all_flag=false" >> $GITHUB_OUTPUT
          fi
          CHANGED_RECIPES=$(echo "$CHANGED_RECIPES" | sed 's/ *$//')

          if [ -z "$CHANGED_RECIPES" ]; then
            echo "No recipes changed."
            echo "changed_recipes_space_separated=" >> $GITHUB_OUTPUT
            echo "has_changed_recipes=false" >> $GITHUB_OUTPUT
          else
            echo "Changed recipes found (space separated list):"
            echo "$CHANGED_RECIPES"
            echo "changed_recipes_space_separated=$CHANGED_RECIPES" >> $GITHUB_OUTPUT
            echo "has_changed_recipes=true" >> $GITHUB_OUTPUT
          fi
        shell: bash

      - name: Update Repository and Stage Dependency Infos
        id: generate-deps
        if: steps.detect-changes.outputs.has_changed_recipes == 'true'
        run: |
          echo "Updating HaikuPorter repository to generate/update all .DependencyInfo files..."
          echo "Working on commit: ${{ github.sha }}"
          git log --oneline -n 3

          LICENSES_DIR_NAME=$(ls -d ${{ github.workspace }}/haiku-licenses-*/ | head -n 1 | xargs basename)
          echo "Using licenses directory: $LICENSES_DIR_NAME at ${{ github.workspace }}/$LICENSES_DIR_NAME"

          echo "Generating .DependencyInfo files for current commit state..."
          haikuporter -q --config="${{ github.workspace }}/haikuports.conf" --licenses="${{ github.workspace }}/$LICENSES_DIR_NAME" --repository-update

          echo "Repository update completed. Generated .DependencyInfo files:"
        shell: bash

      - name: Package changed ports
        id: package-ports
        if: steps.detect-changes.outputs.has_changed_recipes == 'true'
        run: |
          echo "Packaging changed ports directories..."
          CHANGED_RECIPES='${{ steps.detect-changes.outputs.changed_recipes_space_separated }}'
          echo "Changed recipes: $CHANGED_RECIPES"

          mkdir -p changed_ports_temp

          CHANGED_PATHS=$(git diff --name-only origin/master HEAD -- '*-*/*' | xargs echo )
          # place the file in the same location but in the temp directory
          for path in $CHANGED_PATHS; do
            cp -aRv --parents $path changed_ports_temp/ || true
          done

          if [ -d "changed_ports_temp" ] && [ "$(ls -A changed_ports_temp)" ]; then
            tar -czf changed_ports.tar.gz -C changed_ports_temp .
            echo "Created changed_ports.tar.gz with contents:"
            tar -tzf changed_ports.tar.gz
          else
            echo "No port directories found to package"
            tar -czf changed_ports.tar.gz --files-from /dev/null
          fi

          rm -rf changed_ports_temp
        shell: bash

      - name: Cache .DependencyInfo files and changed ports
        id: cache-deps
        uses: actions/cache@v4
        with:
          path: |
            repository/*
            changed_ports.tar.gz
          key: ${{ runner.os }}-haiku-deps-${{ github.sha }}


  build-haikuports:
    runs-on: ubuntu-latest
    needs: prepare-build
    if: needs.prepare-build.outputs.has_changed_recipes == 'true'

    steps:
      - name: Restore cached DependencyInfo files and changed ports
        id: restore-cache
        uses: actions/cache/restore@v4
        with:
          path: |
            repository/*
            changed_ports.tar.gz
          key: ${{ runner.os }}-haiku-deps-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-haiku-deps-${{ github.sha }}

      - name: Debug cache restore results
        run: |
          echo "=== DEBUG: Cache restore results ==="
          echo "Cache hit result: ${{ steps.restore-cache.outputs.cache-hit }}"
          echo "Cache key used: ${{ runner.os }}-haiku-deps-${{ github.sha }}"
          echo "Files in current directory:"
          ls -la
          echo "Looking for repository directory:"
          if [ -d "repository" ]; then
            echo "✓ repository directory found"
          else
            echo "✗ repository directory NOT found"
          fi
          echo "Looking for changed_ports.tar.gz:"
          if [ -f "changed_ports.tar.gz" ]; then
            echo "✓ changed_ports.tar.gz found"
            echo "Size: $(du -h changed_ports.tar.gz | cut -f1)"
            echo "Contents preview:"
            tar -tzf changed_ports.tar.gz
          else
            echo "✗ changed_ports.tar.gz NOT found"
          fi

      - name: Start Haiku VM container
        env:
          VM_CPU: 4
          VM_RAM: 15G
        run: |
          echo "Starting Haiku VM container..."
          docker run -d --name haiku-vm \
            -e VM_CPU="$VM_CPU" \
            -e VM_RAM="$VM_RAM" \
            docker.io/hectorm/qemu-haiku:latest

          echo "Waiting for container to be ready..."
          timeout 600 docker exec haiku-vm sh -c 'container-init & timeout 600 vmshell exit 0'
          echo "Container should be ready."

      - name: Install build dependencies and compilation tools in VM
        run: |
          echo "Installing basic build tools in VM (dependencies will be calculated later)..."
          docker exec haiku-vm vmshell pkgman install -y \
            haikuporter
          echo "Basic build tools installation completed."

      - name: Transfer changed ports to VM
        run: |
          echo "Creating base haikuports directory structure in VM..."
          docker exec haiku-vm vmshell "mkdir -p /boot/home/haikuports"

          if [ -f "changed_ports.tar.gz" ]; then
            echo "Transferring changed_ports.tar.gz to VM..."
            cat changed_ports.tar.gz | docker exec -i haiku-vm vmshell "cat > /boot/home/haikuports/changed_ports.tar.gz"
            echo "Extracting changed ports in VM..."
            docker exec haiku-vm vmshell "cd /boot/home/haikuports && tar -xzf changed_ports.tar.gz"
            echo "Transferred and extracted changed ports to /boot/home/haikuports in VM."
            docker exec haiku-vm vmshell "echo 'Contents of /boot/home/haikuports:'; find /boot/home/haikuports/"
          else
            echo "✗ changed_ports.tar.gz not found on runner. Cannot transfer ports."
            exit 1
          fi

      - name: Setup HaikuPorter and place .DependencyInfo files in VM
        run: |
          docker exec haiku-vm vmshell "mkdir -p /boot/home/config/settings"
          docker exec haiku-vm vmshell "echo 'TREE_PATH=\"/boot/home/haikuports\"' > /boot/home/config/settings/haikuports.conf"
          docker exec haiku-vm vmshell "echo 'PACKAGER=\"GitHub Actions Builder <actions@github.com>\"' >> /boot/home/config/settings/haikuports.conf"
          docker exec haiku-vm vmshell "echo 'TARGET_ARCHITECTURE=\"x86_64\"' >> /boot/home/config/settings/haikuports.conf"
          docker exec haiku-vm vmshell "echo 'RecipeFormatVersion=1' > ~/haikuports/FormatVersions"

          echo "--- Transferring cached dependency files to VM ---"
          if [ -d "repository" ]; then
            echo "Creating dependency-infos.tar.gz on runner..."
            tar -czf dependency-infos.tar.gz -C repository .
            echo "Transferring dependency-infos.tar.gz to VM..."
            cat dependency-infos.tar.gz | docker exec -i haiku-vm vmshell "mkdir -p /boot/home/haikuports/repository && cat > /boot/home/haikuports/dependency-infos.tar.gz"
            docker exec haiku-vm vmshell "cd /boot/home/haikuports && tar -xzf dependency-infos.tar.gz -C repository"
            echo "Transferred and extracted dependency-infos.tar.gz to /boot/home/haikuports/repository in VM."
          else
            echo "✗ repository directory not found on runner. No .DependencyInfo files to transfer."
            docker exec haiku-vm vmshell "mkdir -p /boot/home/haikuports/repository"
          fi

      - name: Calculate and install build dependencies in VM
        run: |
          echo "Calculating build dependencies for changed recipes in VM..."
          CHANGED_RECIPES='${{ needs.prepare-build.outputs.changed_recipes_space_separated }}'
          echo "Changed recipes: $CHANGED_RECIPES"

          echo "Using HaikuPorter in VM to calculate raw dependencies..."
          RAW_DEPS_LIST_STRING=$(docker exec haiku-vm vmshell "cd /boot/home/haikuports && haikuporter --no-repository-update --list-dependencies $CHANGED_RECIPES" | grep ">" | sed -e 's/^[[:space:]]*>[[:space:]]*//' -e 's/[[:space:]]*\(->\|-\)[[:space:]].*//' | sort -u)

          RESOLVED_DEPENDENCIES_LIST=()
          if [ -z "$RAW_DEPS_LIST_STRING" ]; then
            echo "No dependencies found by HaikuPorter."
          else
            echo "Raw dependencies found from HaikuPorter:"
            echo "$RAW_DEPS_LIST_STRING"
            echo "Filtering conflicting package versions..."

            declare -A chosen_package_versions
            declare -A chosen_package_entries

            # Function to derive conflict key (base package name)
            # Input: a clean package string (name-version or name-version-release)
            # Output: a clean base package name (e.g., libfoo_devel)
            derive_conflict_key_from_clean_string() {
                local _pkg_str="$1"
                local _name_part_analysis="$_pkg_str"
                # Try to parse off version and release to get to a "name part"
                if [[ "$_pkg_str" =~ ^(.*)-([0-9][^-._]*([._-][^-._]+)*)(-[0-9]+)?$ ]]; then # Handles name-version or name-version-release
                    _name_part_analysis="${BASH_REMATCH[1]}"
                fi

                local _key_base_name="$_name_part_analysis"
                local _key_suffix=""

                if [[ "$_name_part_analysis" =~ ^(.*?)(_devel|_debuginfo|_doc|_test|_tools|_common|_x86|_source|_headers|_examples|_data|)$ ]]; then
                    _potential_base="${BASH_REMATCH[1]}"
                    if [[ -n "$_potential_base" ]]; then
                        _key_base_name="$_potential_base"
                        _key_suffix="${BASH_REMATCH[2]}"
                    fi
                fi

                if [[ "$_key_base_name" =~ ^(.*[a-zA-Z_])([0-9]+([._][0-9]+)*)$ ]]; then # More specific version stripping from base
                    if [[ -n "${BASH_REMATCH[1]}" ]]; then
                        _key_base_name="${BASH_REMATCH[1]}"
                    fi
                fi
                echo "${_key_base_name}${_key_suffix}"
            }

            OLD_IFS="$IFS"
            IFS=$'\n'
            for raw_dep_entry_with_tab in $RAW_DEPS_LIST_STRING; do
              IFS="$OLD_IFS" # Restore IFS for internal processing
              local dep_entry=$(echo "$raw_dep_entry_with_tab" | xargs) # Clean entry: remove leading/trailing whitespace
              if [ -z "$dep_entry" ]; then continue; fi

              original_dep_entry="$dep_entry"
              name_part_analysis="$dep_entry"
              version_str="0" # Default for comparison if no version found

              # Try to parse name-version-release or name-version
              # Example: libfoo-devel-1.2.3-1 -> name_part_analysis=libfoo-devel, version_str=1.2.3
              # Example: libfoo-1.2-beta1-1 -> name_part_analysis=libfoo, version_str=1.2-beta1
              # Example: libunibreak4.0_devel-4.0-2 -> name_part_analysis=libunibreak4.0_devel, version_str=4.0
              
              temp_str_for_parsing="$dep_entry"
              # Tentatively extract release part (everything after the last hyphen)
              release_candidate="${temp_str_for_parsing##*-}"
              name_and_version_candidate="${temp_str_for_parsing%-*}"

              if [[ "$name_and_version_candidate" =~ ^(.*)-([0-9][^-]*)$ ]]; then
                  # Common case: name-version or name-version (where version was extracted from name-version-release)
                  name_part_analysis="${BASH_REMATCH[1]}"
                  version_str="${BASH_REMATCH[2]}"
              elif [[ "$dep_entry" =~ ^(.*)-([0-9][^-]*)$ ]]; then
                  # Case: name-version (no separate release part in original string)
                  name_part_analysis="${BASH_REMATCH[1]}"
                  version_str="${BASH_REMATCH[2]}"
              else
                  # No standard version pattern found at the end, treat whole entry as name_part_analysis
                  name_part_analysis="$dep_entry"
                  version_str="0" # Unversioned or unknown version format
              fi

              # Determine conflict_resolution_key from name_part_analysis
              key_base_name="${name_part_analysis}"
              key_suffix=""

              # Extract common suffixes like _devel, _doc, etc.
              if [[ "$name_part_analysis" =~ ^(.*?)(_devel|_debuginfo|_doc|_test|_tools|_common|_x86|_source|_headers|_examples|_data|)$ ]]; then
                  potential_base="${BASH_REMATCH[1]}"
                  if [[ -n "$potential_base" ]]; then # Ensure base is not empty
                      key_base_name="$potential_base"
                      key_suffix="${BASH_REMATCH[2]}"
                  fi
              fi

              # Remove embedded version numbers from key_base_name (e.g., libfoo4.0 -> libfoo, icu71 -> icu, python3 -> python)
              if [[ "$key_base_name" =~ ^(.*[a-zA-Z_])([0-9]+[0-9\._]*)$ ]]; then
                  # Check if the first part (non-version) is non-empty
                  if [[ -n "${BASH_REMATCH[1]}" ]]; then
                      key_base_name="${BASH_REMATCH[1]}"
                  fi
              fi
              conflict_key="${key_base_name}${key_suffix}"

              echo "  Processing: '$original_dep_entry' -> name_part_analysis='$name_part_analysis', version_str='$version_str', conflict_key='$conflict_key'"

              current_stored_version=${chosen_package_versions[$conflict_key]:-}

              if [[ -z "$current_stored_version" ]]; then # No package for this conflict_key yet
                chosen_package_versions[$conflict_key]="$version_str"
                chosen_package_entries[$conflict_key]="$original_dep_entry"
                echo "    Adding new: '$original_dep_entry' (Version: $version_str)"
              else
                # Compare version_str with current_stored_version using sort -V
                # winner will be the highest version string
                winner=$(printf "%s\n%s" "$current_stored_version" "$version_str" | sort -V | tail -n1)
                
                if [[ "$winner" == "$version_str" && "$version_str" != "$current_stored_version" ]]; then
                  echo "    Replacing '${chosen_package_entries[$conflict_key]}' (Version: $current_stored_version) with '$original_dep_entry' (Version: $version_str)"
                  chosen_package_versions[$conflict_key]="$version_str"
                  chosen_package_entries[$conflict_key]="$original_dep_entry"
                else
                  echo "    Keeping existing: '${chosen_package_entries[$conflict_key]}' (Version: $current_stored_version) over '$original_dep_entry' (Version: $version_str)"
                fi
              fi
            done
            IFS="$OLD_IFS" # Restore IFS

            if [ ${#chosen_package_entries[@]} -gt 0 ]; then
              for key in "${!chosen_package_entries[@]}"; do
                RESOLVED_DEPENDENCIES_LIST+=("${chosen_package_entries[$key]}")
              done
            fi
            echo "After version conflict resolution, chosen dependencies:"
            printf "  %s\n" "${RESOLVED_DEPENDENCIES_LIST[@]}" # Print each on a new line for clarity
          fi

          # Filter resolved dependencies against available repository packages
          echo "Fetching list of all available packages from repositories..."
          ALL_RAW_AVAILABLE_PACKAGES_OUTPUT=$(docker exec haiku-vm vmshell "pkgman search -a | sed s/^........//g | cut -d \" \" -f 1")
          declare -A all_available_packages_map
          while IFS= read -r pkg_name_full_raw; do
              local_trimmed_pkg_name_full=$(echo "$pkg_name_full_raw" | xargs) # Trim whitespace, gives name-version-release
              if [ -n "$local_trimmed_pkg_name_full" ]; then
                  # Strip release number to get name-version, e.g., "foo-1.2.3-1" becomes "foo-1.2.3"
                  local_pkg_name_nv=$(echo "$local_trimmed_pkg_name_full" | sed 's/^\(.*\)-[0-9]\+$/\1/')
                  all_available_packages_map["$local_pkg_name_nv"]=1 # Store by name-version
              fi
          done <<< "$ALL_RAW_AVAILABLE_PACKAGES_OUTPUT"
          echo "Found ${#all_available_packages_map[@]} available packages in repositories."

          FINAL_INSTALL_LIST=()
          if [ ${#RESOLVED_DEPENDENCIES_LIST[@]} -gt 0 ]; then
            echo "Filtering resolved dependencies against available repository packages..."
            for dep_to_check in "${RESOLVED_DEPENDENCIES_LIST[@]}"; do
              trimmed_dep_to_check=$(echo "$dep_to_check" | xargs)
              # trimmed_dep_to_check should now be clean name-version (e.g., openexr3.2_devel-3.2.4)
              if [[ -n "${all_available_packages_map[$trimmed_dep_to_check]}" ]]; then # Check if this name-version exists in the map
                FINAL_INSTALL_LIST+=("$trimmed_dep_to_check") # Add the name-version string for pkgman to install
              else
                echo "Warning: Dependency '$trimmed_dep_to_check' (chosen after conflict resolution) not found in available packages, skipping."
              fi
            done
          fi

          if [ ${#FINAL_INSTALL_LIST[@]} -eq 0 ]; then
            echo "No external dependencies to install (either none found, all are built locally, or all filtered out)."
            DEPENDENCIES=""
          else
            DEPENDENCIES=$(echo "${FINAL_INSTALL_LIST[@]}" | xargs) # Space separated string
            echo "Installing calculated dependencies in VM..."
            docker exec haiku-vm vmshell "pkgman install -y $DEPENDENCIES" || {
              echo "Warning: Some dependencies failed to install, continuing with build..."
            }
          fi
          echo "Dependencies installation step completed."

      - name: Build modified packages with haikuporter
        id: build-packages
        run: |
          docker exec haiku-vm vmshell "cd /boot/home/haikuports && \
            echo 'Reading list of changed packages' && \
            RECIPE_ARGS='${{ needs.prepare-build.outputs.changed_recipes_space_separated }}' && \
            echo \"Changed packages: \$RECIPE_ARGS\" && \
            if haikuporter \$RECIPE_ARGS -j4 -G --no-repository-update --missing-dependencies; then \
              echo \"✓ HaikuPorter build completed successfully.\" ; \
            else \
              BUILD_FAILURE_CODE=$? ; \
              echo \"✗ HaikuPorter build failed with exit code $BUILD_FAILURE_CODE.\" ; \
              exit $BUILD_FAILURE_CODE ; \
            fi ; \
            \
            echo \"Build summary:\" ; \
            NUM_PACKAGES=$(echo \"$RECIPE_ARGS\" | wc -w) ; \
            echo \"- Packages attempted: $NUM_PACKAGES\" ; \
            if [ -d packages ] && ls packages/*.hpkg >/dev/null 2>&1; then \
              echo \"- Built packages: \$(ls packages/*.hpkg | wc -l)\" ; \
              echo \"- Package files: \$(ls packages/*.hpkg | xargs basename -a | tr '\n' ' ')\" ; \
            else \
              echo \"- Built packages: 0\" ; \
            fi"

      - name: Collect build artifacts
        run: |
          mkdir -p build-artifacts
          docker exec haiku-vm vmshell "cd /boot/home/haikuports && \
            if [ -d packages ] && ls packages/*.hpkg >/dev/null 2>&1; then
              echo 'Collecting built packages:'
              ls -la packages/*.hpkg
              tar -czf /boot/home/haikuports/built-packages.tar.gz packages/*.hpkg
            else
              echo 'No packages were built'
              tar -czf /boot/home/haikuports/built-packages.tar.gz --files-from /dev/null
            fi
            if [ -d work ]; then
              find work -name '*.log' -type f | head -n 20 | tar -czf /boot/home/haikuports/build-logs.tar.gz -T - 2>/dev/null || \
              tar -czf /boot/home/haikuports/build-logs.tar.gz --files-from /dev/null
            fi"
          docker exec haiku-vm vmshell cat /boot/home/haikuports/built-packages.tar.gz > build-artifacts/built-packages.tar.gz || true
          docker exec haiku-vm vmshell cat /boot/home/haikuports/build-logs.tar.gz > build-artifacts/build-logs.tar.gz || true

      - name: Upload build artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: haikuports-build-${{ github.run_number }}
          path: build-artifacts/
          retention-days: 30

      - name: Display build summary
        if: always()
        run: |
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow:** ${{ github.workflow }}" >> $GITHUB_STEP_SUMMARY
          echo "**Run Number:** ${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          PACKAGES_STRING='${{ needs.prepare-build.outputs.changed_recipes_space_separated }}'
          echo "**Packages processed:** $PACKAGES_STRING" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Artifacts:** Check the uploaded build artifacts for built packages and logs." >> $GITHUB_STEP_SUMMARY
