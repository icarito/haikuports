name: Build HaikuPorts packages

on:
  workflow_dispatch:
  push:
    branches: [ main, master, development ]
  pull_request:
    branches: [ main, master, development ]

jobs:
  build-haikuports:
    runs-on: ubuntu-latest
    env:
      VM_CPU: 4
      VM_RAM: 15G
    container: docker.io/hectorm/qemu-haiku:latest

    steps:
      - name: Wait until the VM is ready
        run: container-init & timeout 600 vmshell exit 0

      - name: Install essential workflow tools
        run: |
          vmshell "echo 'Installing essential workflow tools...' && \
            pkgman install -y \
              git jq haikuporter coreutils bash sed grep gawk findutils \
              pkgconf curl xz_utils tar gzip unzip zip python3.10 make gcc binutils"

#      - name: Install build dependencies and compilation tools
#        run: |
#          # Instalar paquetes esenciales de compilación basados en la lista del usuario
#          vmshell pkgman install -y jq haikuporter


#          vmshell git clone https://github.com/haikuports/haikuporter.git /boot/home/haikuporter

      - name: Checkout HaikuPorts repository in VM
        run: |
          vmshell "mkdir -p /boot/home/haikuports && \
            git clone https://github.com/${GITHUB_REPOSITORY}.git /boot/home/haikuports && \
            cd /boot/home/haikuports && \
            git checkout ${GITHUB_SHA}"

      - name: Setup HaikuPorter
        run: |
          vmshell "mkdir -p /boot/home/config/settings"
          vmshell "echo 'TREE_PATH="/boot/home/haikuports"' > /boot/home/config/settings/haikuports.conf"
          vmshell "echo 'PACKAGER=\"GitHub Actions Builder \<actions@github.com\>\"' >> /boot/home/config/settings/haikuports.conf"

      - name: Generate dynamic dependency list
        id: generate_deps
        uses: anholt/actions-haiku/vmshell@master
        env: # Pass the PACKAGES_JSON as an environment variable to the vmshell
          PACKAGES_JSON: ${{ steps.detect-changes.outputs.packages }}
        with:
          script: |
            echo "Starting dynamic dependency generation..."
            # Initialize an empty list file
            true > /tmp/all_dependencies.list
            true > /tmp/base_pkgs_being_built.list
            true > /tmp/final_prereqs.list

            echo "PACKAGES_JSON content: $PACKAGES_JSON"

            # Extract base package names from the JSON list of changed package directories
            # Ensure jq processes the string correctly, it might need to be passed without outer single quotes in some contexts
            echo "$PACKAGES_JSON" | jq -r '.[] | select(length > 0) | split("/") | .[-1]' > /tmp/base_pkgs_being_built.list

            echo "Base packages being built:"
            cat /tmp/base_pkgs_being_built.list

            # Iterate through each package name (not directory) to get its dependencies
            # The PACKAGES_JSON contains "category/pkgname", we need "pkgname"
            echo "$PACKAGES_JSON" | jq -r '.[] | select(length > 0) | split("/") | .[-1]' | while IFS= read -r pkg_name; do
              if [ -z "$pkg_name" ]; then
                echo "Warning: Encountered an empty package name after jq processing."
                continue
              fi
              echo "Listing dependencies for package: $pkg_name"
              # Run haikuporter to list dependencies for the package name.
              # Suppress stderr for this command for now, and ensure it doesn't halt the script on error.
              # Using `set +e` and `set -e` to gracefully handle potential errors from haikuporter
              set +e
              haikuporter --list-dependencies "$pkg_name" >> /tmp/all_dependencies.list
              hp_exit_code=$?
              if [ $hp_exit_code -ne 0 ]; then
                echo "Note: haikuporter --list-dependencies for $pkg_name exited with code $hp_exit_code (errors suppressed)."
              fi
              set -e
            done

            echo "All raw dependencies collected (/tmp/all_dependencies.list):"
            cat /tmp/all_dependencies.list

            # Create a unique list of dependencies
            sort -u /tmp/all_dependencies.list > /tmp/unique_dependencies.list
            echo "Unique dependencies (/tmp/unique_dependencies.list):"
            cat /tmp/unique_dependencies.list

            # Filter out the packages that are being built themselves and their common variants
            echo "Filtering initial packages and their variants from the dependency list..."
            while IFS= read -r dep; do
              is_initial_or_variant=false
              # Strip common prefixes for base name comparison
              dep_base_name=$(echo "$dep" | sed -E 's/^(cmd:|lib:|devel:|package:|hpkg:|generic:|source:)//')

              while IFS= read -r initial_pkg_name; do
                # Check if dep (prefixed) or dep_base_name is the initial package or a direct variant
                if [ "$dep" = "$initial_pkg_name" ] || \
                   [ "$dep_base_name" = "$initial_pkg_name" ] || \
                   [ "$dep_base_name" = "${initial_pkg_name}_devel" ] || \
                   [ "$dep_base_name" = "${initial_pkg_name}_libs" ] || \
                   [ "$dep_base_name" = "${initial_pkg_name}_tools" ] || \
                   [ "$dep_base_name" = "${initial_pkg_name}_x86" ] || \
                   [ "$dep_base_name" = "${initial_pkg_name}_any" ] || \
                   [ "$dep_base_name" = "${initial_pkg_name}_source" ] || \
                   [ "$dep_base_name" = "${initial_pkg_name}_source_kit" ] || \
                   [ "$dep_base_name" = "${initial_pkg_name}_debuginfo" ]; then
                  is_initial_or_variant=true
                  break
                fi
              done < /tmp/base_pkgs_being_built.list

              if [ "$is_initial_or_variant" = "false" ]; then
                echo "$dep" >> /tmp/final_prereqs.list
              fi
            done < /tmp/unique_dependencies.list

            echo "Final prerequisite list to be installed (/tmp/final_prereqs.list):"
            cat /tmp/final_prereqs.list
            echo "Dependency list generation complete."
            # The next step ("Install build dependencies") should use /tmp/final_prereqs.list

      - name: Install dynamic build dependencies
        uses: anholt/actions-haiku/vmshell@master
        with:
          script: |
            if [ -f /tmp/final_prereqs.list ] && [ -s /tmp/final_prereqs.list ]; then
              echo 'Installing dynamically identified build prerequisites from /tmp/final_prereqs.list...'
              DEPS_TO_INSTALL=$(cat /tmp/final_prereqs.list | tr '\n' ' ' | sed 's/ $//') # Convert newlines to spaces and remove trailing space
              if [ -n "$DEPS_TO_INSTALL" ]; then
                echo "Dynamic dependencies: $DEPS_TO_INSTALL"
                set +e # Allow pkgman to fail on some packages if needed, though -y should handle most
                pkgman install -y $DEPS_TO_INSTALL
                pm_exit_code=$?
                if [ $pm_exit_code -ne 0 ]; then
                    echo "Warning: pkgman install for dynamic dependencies exited with code $pm_exit_code."
                fi
                set -e
              else
                echo 'Final prerequisite list was empty after processing.'
              fi
            else
              echo 'No dynamic build prerequisites to install as /tmp/final_prereqs.list is missing or empty.'
            fi

      - name: Detect modified packages compared to master
        id: detect-changes
        run: |
          # Cambiar al directorio de haikuports dentro del VM
          vmshell "cd ~/haikuports && \
            # Configurar git para evitar warnings
            git config --global user.email 'actions@github.com' && \
            git config --global user.name 'GitHub Actions' && \

            # Obtener la lista de directorios modificados respecto a master
            if git rev-parse --verify origin/master >/dev/null 2>&1; then
              BASE_REF='origin/master'
            elif git rev-parse --verify master >/dev/null 2>&1; then
              BASE_REF='master'
            else
              echo 'No master branch found, building all packages'
              BASE_REF='HEAD~1'
            fi

            echo \"Comparing against: \$BASE_REF\"

            # Encontrar directorios de paquetes modificados
            CHANGED_DIRS=\$(git diff --name-only \$BASE_REF...HEAD * | \
              cut -d'/' -f2 | sort -u)
            echo $CHANGED_DIRS

            if [ -z \"\$CHANGED_DIRS\" ]; then
              echo 'No packages to build'
              echo 'packages=' >> /tmp/packages_to_build.txt
            else
              echo 'Packages to build:'
              echo \"\$CHANGED_DIRS\" | tee /tmp/packages_to_build.txt
              # Convertir a formato para GitHub Actions
              PACKAGES_JSON=\$(echo \"\$CHANGED_DIRS\" | jq -R -s -c 'split(\"\n\") | map(select(length > 0))')
              echo \"packages=\$PACKAGES_JSON\" >> /tmp/packages_to_build.txt
            fi"

          # Leer el resultado del VM
          PACKAGES=$(vmshell cat /tmp/packages_to_build.txt | grep '^packages=' | cut -d'=' -f2-)
          echo "packages=$PACKAGES" >> $GITHUB_OUTPUT

      - name: Build modified packages with haikuporter
        if: steps.detect-changes.outputs.packages != '[]' && steps.detect-changes.outputs.packages != ''
        run: |
          PACKAGES='${{ steps.detect-changes.outputs.packages }}'
          echo "Building packages: $PACKAGES"

          vmshell "cd ~/haikuports && \
            # Crear directorios necesarios
            mkdir -p packages && \
            mkdir -p repository && \

            # Función para construir un paquete
            build_package() {
              local pkg_dir=\$1
              local pkg_name=\$(basename \$pkg_dir)
              local category=\$(dirname \$pkg_dir)

              echo \"Building package: \$pkg_dir\"

              # Intentar construir el paquete con dependencias faltantes
              if haikuporter \$pkg_name -j4; then
                echo \"✓ Successfully built \$pkg_dir\"
                return 0
              else
                echo \"✗ Failed to build \$pkg_dir\"
                return 1
              fi
            }

            # Procesar cada paquete modificado
            SUCCESS_COUNT=0
            FAILED_COUNT=0
            FAILED_PACKAGES=''

            # Convertir JSON a lista y procesar cada paquete
            echo '$PACKAGES' | jq -r '.[]' | while read pkg_dir; do
              if [ -n \"\$pkg_dir\" ]; then
                if build_package \"\$pkg_dir\"; then
                  SUCCESS_COUNT=\$((SUCCESS_COUNT + 1))
                else
                  FAILED_COUNT=\$((FAILED_COUNT + 1))
                  FAILED_PACKAGES=\"\$FAILED_PACKAGES \$pkg_dir\"
                fi
              fi
            done

            echo \"Build summary:\"
            echo \"- Successful builds: \$SUCCESS_COUNT\"
            echo \"- Failed builds: \$FAILED_COUNT\"
            if [ \$FAILED_COUNT -gt 0 ]; then
              echo \"- Failed packages:\$FAILED_PACKAGES\"
            fi"

      - name: Collect build artifacts
        if: always()
        run: |
          # Crear directorio para artefactos
          mkdir -p build-artifacts

          # Copiar paquetes construidos desde el VM
          vmshell "cd ~/haikuports && \
            if [ -d packages ] && [ \"\$(ls -A packages/*.hpkg 2>/dev/null)\" ]; then
              echo 'Found built packages:'
              ls -la packages/*.hpkg || true
              tar -czf /tmp/built-packages.tar.gz packages/*.hpkg
            else
              echo 'No packages were built'
              touch /tmp/built-packages.tar.gz
            fi

            # Recopilar logs si existen
            if [ -d work ]; then
              find work -name '*.log' -type f | head -20 | xargs tar -czf /tmp/build-logs.tar.gz 2>/dev/null || touch /tmp/build-logs.tar.gz
            else
              touch /tmp/build-logs.tar.gz
            fi"

          # Copiar artefactos del VM al runner
          vmshell cat /tmp/built-packages.tar.gz > build-artifacts/built-packages.tar.gz
          vmshell cat /tmp/build-logs.tar.gz > build-artifacts/build-logs.tar.gz

      - name: Upload build artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: haikuports-build-${{ github.run_number }}
          path: build-artifacts/
          retention-days: 30

      - name: Display build summary
        if: always()
        run: |
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow:** ${{ github.workflow }}" >> $GITHUB_STEP_SUMMARY
          echo "**Run Number:** ${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          PACKAGES='${{ steps.detect-changes.outputs.packages }}'
          if [ "$PACKAGES" = "[]" ] || [ -z "$PACKAGES" ]; then
            echo "**Result:** No packages needed to be built" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Packages processed:** $PACKAGES" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Artifacts:** Check the uploaded build artifacts for built packages and logs" >> $GITHUB_STEP_SUMMARY
          fi
